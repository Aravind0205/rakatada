'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var initializeConfig = require('./initializeConfig-cde42612.js');
var createIntl = require('./createIntl-dfba4462.js');
require('intl-messageformat');
require('react');

function createTranslatorImpl(_ref, namespacePrefix) {
  let {
    getMessageFallback,
    messages,
    namespace,
    onError,
    ...rest
  } = _ref;
  // The `namespacePrefix` is part of the type system.
  // See the comment in the function invocation.
  messages = messages[namespacePrefix];
  namespace = createIntl.resolveNamespace(namespace, namespacePrefix);
  const translator = createIntl.createBaseTranslator({
    ...rest,
    onError,
    getMessageFallback,
    messages,
    namespace
  });
  const originalRich = translator.rich;
  function base() {
    return translator(...arguments);
  }

  // Augment `t.rich` to return plain strings
  base.rich = (key, values, formats) => {
    // `chunks` is returned as a string when no React element
    // is used, therefore it's safe to cast this type.
    const result = originalRich(key, values, formats);

    // When only string chunks are provided to the parser, only strings should be returned here.
    if (typeof result !== 'string') {
      const error = new initializeConfig.IntlError(initializeConfig.IntlErrorCode.FORMATTING_ERROR, "`createTranslator` only accepts functions for rich text formatting that receive and return strings.\n\nE.g. t.rich('rich', {b: (chunks) => `<b>${chunks}</b>`})" );
      onError(error);
      return getMessageFallback({
        error,
        key,
        namespace
      });
    }
    return result;
  };
  base.raw = translator.raw;
  return base;
}

/**
 * Translates messages from the given namespace by using the ICU syntax.
 * See https://formatjs.io/docs/core-concepts/icu-syntax.
 *
 * If no namespace is provided, all available messages are returned.
 * The namespace can also indicate nesting by using a dot
 * (e.g. `namespace.Component`).
 */
function createTranslator(_ref) {
  let {
    getMessageFallback = initializeConfig.defaultGetMessageFallback,
    messages,
    namespace,
    onError = initializeConfig.defaultOnError,
    ...rest
  } = _ref;
  // We have to wrap the actual function so the type inference for the optional
  // namespace works correctly. See https://stackoverflow.com/a/71529575/343045
  // The prefix ("!") is arbitrary.
  return createTranslatorImpl({
    ...rest,
    onError,
    getMessageFallback,
    messages: {
      '!': messages
    },
    namespace: namespace ? "!.".concat(namespace) : '!'
  }, '!');
}

exports.IntlError = initializeConfig.IntlError;
exports.IntlErrorCode = initializeConfig.IntlErrorCode;
exports.initializeConfig = initializeConfig.initializeConfig;
exports.createBaseTranslator = createIntl.createBaseTranslator;
exports.createFormatter = createIntl.createFormatter;
exports.createIntl = createIntl.createIntl;
exports.createTranslator = createTranslator;
