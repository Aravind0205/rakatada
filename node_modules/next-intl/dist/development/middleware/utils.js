'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var utils = require('../shared/utils.js');

function getLocaleFromPathname(pathname) {
  return pathname.split('/')[1];
}
function getInternalTemplate(pathnames, pathname) {
  for (const [internalPathname, localizedPathnamesOrPathname] of Object.entries(pathnames)) {
    if (typeof localizedPathnamesOrPathname === 'string') {
      const localizedPathname = localizedPathnamesOrPathname;
      if (utils.matchesPathname(localizedPathname, pathname)) {
        return [undefined, internalPathname];
      }
    } else {
      for (const [locale, localizedPathname] of Object.entries(localizedPathnamesOrPathname)) {
        if (utils.matchesPathname(localizedPathname, pathname)) {
          return [locale, internalPathname];
        }
      }
    }
  }
  return [undefined, undefined];
}
function formatTemplatePathname(sourcePathname, sourceTemplate, targetTemplate, localePrefix) {
  const params = getRouteParams(sourceTemplate, sourcePathname);
  let targetPathname = '';
  if (localePrefix) {
    targetPathname = "/".concat(localePrefix);
  }
  targetPathname += formatPathname(targetTemplate, params);
  if (targetPathname.endsWith('/')) {
    targetPathname = targetPathname.slice(0, -1);
  }
  return targetPathname;
}

/**
 * Removes potential locales from the pathname.
 */
function getNormalizedPathname(pathname, locales) {
  // Add trailing slash for consistent handling
  // both for the root as well as nested paths
  if (!pathname.endsWith('/')) {
    pathname += '/';
  }
  const match = pathname.match("^/(".concat(locales.join('|'), ")(.*)"));
  let result = match ? match[2] : pathname;

  // Remove trailing slash
  if (result.endsWith('/') && result !== '/') {
    result = result.slice(0, -1);
  }
  return result;
}
function getKnownLocaleFromPathname(pathname, locales) {
  const pathLocaleCandidate = getLocaleFromPathname(pathname);
  const pathLocale = locales.includes(pathLocaleCandidate) ? pathLocaleCandidate : undefined;
  return pathLocale;
}
function getBasePath(pathname, pathLocale) {
  return pathname.replace("/".concat(pathLocale), '') || '/';
}
function getRouteParams(template, pathname) {
  const regex = utils.templateToRegex(template);
  const match = regex.exec(pathname);
  if (!match) return undefined;
  const params = {};
  for (let i = 1; i < match.length; i++) {
    var _template$match;
    const key = (_template$match = template.match(/\[([^\]]+)\]/g)) === null || _template$match === void 0 ? void 0 : _template$match[i - 1].replace(/[[\]]/g, '');
    if (key) params[key] = match[i];
  }
  return params;
}
function formatPathname(template, params) {
  if (!params) return template;

  // Simplify syntax for optional catchall ('[[...slug]]') so
  // we can replace the value with simple interpolation
  template = template.replaceAll('[[', '[').replaceAll(']]', ']');
  let result = template;
  Object.entries(params).forEach(_ref => {
    let [key, value] = _ref;
    result = result.replace("[".concat(key, "]"), value);
  });
  return result;
}
function getPathWithSearch(pathname, search) {
  let pathWithSearch = pathname;
  if (search) {
    pathWithSearch += search;
  }
  return pathWithSearch;
}
function getHost(requestHeaders) {
  var _ref2, _requestHeaders$get;
  return (_ref2 = (_requestHeaders$get = requestHeaders.get('x-forwarded-host')) !== null && _requestHeaders$get !== void 0 ? _requestHeaders$get : requestHeaders.get('host')) !== null && _ref2 !== void 0 ? _ref2 : undefined;
}
function isLocaleSupportedOnDomain(locale, domain) {
  return domain.defaultLocale === locale || !domain.locales || domain.locales.includes(locale);
}
function getBestMatchingDomain(curHostDomain, locale, domainConfigs) {
  let domainConfig;

  // Prio 1: Stay on current domain
  if (curHostDomain && isLocaleSupportedOnDomain(locale, curHostDomain)) {
    domainConfig = curHostDomain;
  }

  // Prio 2: Use alternative domain with matching default locale
  if (!domainConfig) {
    domainConfig = domainConfigs.find(cur => cur.defaultLocale === locale);
  }

  // Prio 3: Use alternative domain with restricted matching locale
  if (!domainConfig) {
    domainConfig = domainConfigs.find(cur => cur.locales != null && cur.locales.includes(locale));
  }

  // Prio 4: Stay on the current domain if it supports all locales
  if (!domainConfig && (curHostDomain === null || curHostDomain === void 0 ? void 0 : curHostDomain.locales) == null) {
    domainConfig = curHostDomain;
  }

  // Prio 5: Use alternative domain that supports all locales
  if (!domainConfig) {
    domainConfig = domainConfigs.find(cur => !cur.locales);
  }
  return domainConfig;
}

exports.formatPathname = formatPathname;
exports.formatTemplatePathname = formatTemplatePathname;
exports.getBasePath = getBasePath;
exports.getBestMatchingDomain = getBestMatchingDomain;
exports.getHost = getHost;
exports.getInternalTemplate = getInternalTemplate;
exports.getKnownLocaleFromPathname = getKnownLocaleFromPathname;
exports.getLocaleFromPathname = getLocaleFromPathname;
exports.getNormalizedPathname = getNormalizedPathname;
exports.getPathWithSearch = getPathWithSearch;
exports.getRouteParams = getRouteParams;
exports.isLocaleSupportedOnDomain = isLocaleSupportedOnDomain;
