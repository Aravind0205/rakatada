'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var server = require('next/server');
var constants = require('../shared/constants.js');
var utils$1 = require('../shared/utils.js');
var getAlternateLinksHeaderValue = require('./getAlternateLinksHeaderValue.js');
var resolveLocale = require('./resolveLocale.js');
var utils = require('./utils.js');

const ROOT_URL = '/';
function handleConfigDeprecations(config) {
  if (config.routing) {
    const {
      routing
    } = config;
    config = {
      ...config
    };
    delete config.routing;
    if (routing.type === 'prefix') {
      config.localePrefix = routing.prefix;
    } else if (routing.type === 'domain') {
      config.domains = routing.domains.map(cur => ({
        domain: cur.domain,
        defaultLocale: cur.locale,
        locales: [cur.locale]
      }));
    }
    {
      console.error("\n\nThe `routing` option is deprecated, please use `localePrefix` and `domains` instead. Here's your updated configuration:\n\n" + JSON.stringify(config, null, 2) + '\n\nThank you so much for following along with the Server Components beta and sorry for the inconvenience!\n\n');
    }
  }
  if (config.domains) {
    const {
      domains
    } = config;
    config = {
      ...config
    };
    config.domains = domains.map(cur => {
      if (cur.locale) {
        console.error('\n\nThe `domain.locale` option is deprecated, please use `domain.defaultLocale` instead.');
      }
      return {
        ...cur,
        defaultLocale: cur.locale || cur.defaultLocale,
        ...(cur.locale && {
          locales: [cur.locale]
        })
      };
    });
  }
  return config;
}
function receiveConfig(config) {
  var _config$alternateLink, _config$localePrefix, _config$localeDetecti;
  // TODO: Remove before stable release
  config = handleConfigDeprecations(config);
  const result = {
    ...config,
    alternateLinks: (_config$alternateLink = config.alternateLinks) !== null && _config$alternateLink !== void 0 ? _config$alternateLink : true,
    localePrefix: (_config$localePrefix = config.localePrefix) !== null && _config$localePrefix !== void 0 ? _config$localePrefix : 'as-needed',
    localeDetection: (_config$localeDetecti = config.localeDetection) !== null && _config$localeDetecti !== void 0 ? _config$localeDetecti : true
  };
  return result;
}
function createMiddleware(config) {
  const configWithDefaults = receiveConfig(config);

  // Currently only in use to enable a seamless upgrade path from the
  // `{createIntlMiddleware} from 'next-intl/server'` API.
  // TODO: Remove in next major release.
  const matcher = config._matcher;
  return function middleware(request) {
    var _request$cookies$get, _configWithDefaults$d;
    const matches = !matcher || matcher.some(pattern => request.nextUrl.pathname.match(pattern));
    if (!matches) return server.NextResponse.next();
    const {
      domain,
      locale
    } = resolveLocale.default(configWithDefaults, request.headers, request.cookies, request.nextUrl.pathname);
    const hasOutdatedCookie = ((_request$cookies$get = request.cookies.get(constants.COOKIE_LOCALE_NAME)) === null || _request$cookies$get === void 0 ? void 0 : _request$cookies$get.value) !== locale;
    const hasMatchedDefaultLocale = domain ? domain.defaultLocale === locale : locale === configWithDefaults.defaultLocale;
    const domainConfigs = ((_configWithDefaults$d = configWithDefaults.domains) === null || _configWithDefaults$d === void 0 ? void 0 : _configWithDefaults$d.filter(curDomain => utils.isLocaleSupportedOnDomain(locale, curDomain))) || [];
    const hasUnknownHost = configWithDefaults.domains != null && !domain;
    function getResponseInit() {
      const responseInit = {
        request: {
          headers: request.headers
        }
      };
      if (hasOutdatedCookie) {
        responseInit.request.headers = new Headers(responseInit.request.headers);
        responseInit.request.headers.set(constants.HEADER_LOCALE_NAME, locale);
      }
      return responseInit;
    }
    function rewrite(url) {
      return server.NextResponse.rewrite(new URL(url, request.url), getResponseInit());
    }
    function redirect(url, host) {
      const urlObj = new URL(url, request.url);
      if (domainConfigs.length > 0) {
        if (!host) {
          const bestMatchingDomain = utils.getBestMatchingDomain(domain, locale, domainConfigs);
          if (bestMatchingDomain) {
            host = bestMatchingDomain.domain;
            if (bestMatchingDomain.defaultLocale === locale && configWithDefaults.localePrefix === 'as-needed') {
              urlObj.pathname = urlObj.pathname.replace("/".concat(locale), '');
            }
          }
        }
      }
      if (host) {
        urlObj.host = host;
      }
      return server.NextResponse.redirect(urlObj.toString());
    }
    const normalizedPathname = utils.getNormalizedPathname(request.nextUrl.pathname, configWithDefaults.locales);
    const pathLocale = utils.getKnownLocaleFromPathname(request.nextUrl.pathname, configWithDefaults.locales);
    const hasLocalePrefix = pathLocale != null;
    let response;
    let internalTemplateName;
    let pathname = request.nextUrl.pathname;
    if (configWithDefaults.pathnames) {
      let resolvedTemplateLocale;
      [resolvedTemplateLocale = locale, internalTemplateName] = utils.getInternalTemplate(configWithDefaults.pathnames, normalizedPathname);
      if (internalTemplateName) {
        const pathnameConfig = configWithDefaults.pathnames[internalTemplateName];
        const localeTemplate = typeof pathnameConfig === 'string' ? pathnameConfig : pathnameConfig[locale];
        if (utils$1.matchesPathname(localeTemplate, normalizedPathname)) {
          pathname = utils.formatTemplatePathname(normalizedPathname, localeTemplate, internalTemplateName, pathLocale);
        } else {
          const isDefaultLocale = configWithDefaults.defaultLocale === locale || (domain === null || domain === void 0 ? void 0 : domain.defaultLocale) === locale;
          response = redirect(utils.formatTemplatePathname(normalizedPathname, typeof pathnameConfig === 'string' ? pathnameConfig : pathnameConfig[resolvedTemplateLocale], localeTemplate, pathLocale || !isDefaultLocale ? locale : undefined));
        }
      }
    }
    if (!response) {
      if (pathname === ROOT_URL) {
        const pathWithSearch = utils.getPathWithSearch("/".concat(locale), request.nextUrl.search);
        if (configWithDefaults.localePrefix === 'never' || hasMatchedDefaultLocale && configWithDefaults.localePrefix === 'as-needed') {
          response = rewrite(pathWithSearch);
        } else {
          response = redirect(pathWithSearch);
        }
      } else {
        const pathWithSearch = utils.getPathWithSearch(pathname, request.nextUrl.search);
        if (hasLocalePrefix) {
          const basePath = utils.getBasePath(pathWithSearch, pathLocale);
          if (configWithDefaults.localePrefix === 'never') {
            response = redirect(basePath);
          } else if (pathLocale === locale) {
            if (hasMatchedDefaultLocale && configWithDefaults.localePrefix === 'as-needed') {
              response = redirect(basePath);
            } else {
              if (configWithDefaults.domains) {
                const pathDomain = utils.getBestMatchingDomain(domain, pathLocale, domainConfigs);
                if ((domain === null || domain === void 0 ? void 0 : domain.domain) !== (pathDomain === null || pathDomain === void 0 ? void 0 : pathDomain.domain) && !hasUnknownHost) {
                  response = redirect(basePath, pathDomain === null || pathDomain === void 0 ? void 0 : pathDomain.domain);
                } else {
                  response = rewrite(pathWithSearch);
                }
              } else {
                response = rewrite(pathWithSearch);
              }
            }
          } else {
            response = redirect("/".concat(locale).concat(basePath));
          }
        } else {
          if (configWithDefaults.localePrefix === 'never' || hasMatchedDefaultLocale && (configWithDefaults.localePrefix === 'as-needed' || configWithDefaults.domains)) {
            response = rewrite("/".concat(locale).concat(pathWithSearch));
          } else {
            response = redirect("/".concat(locale).concat(pathWithSearch));
          }
        }
      }
    }
    if (hasOutdatedCookie) {
      response.cookies.set(constants.COOKIE_LOCALE_NAME, locale, {
        sameSite: 'strict',
        maxAge: 31536000 // 1 year
      });
    }

    if (configWithDefaults.localePrefix !== 'never' && configWithDefaults.alternateLinks && configWithDefaults.locales.length > 1) {
      var _configWithDefaults$p;
      response.headers.set('Link', getAlternateLinksHeaderValue.default({
        config: configWithDefaults,
        localizedPathnames: internalTemplateName != null ? (_configWithDefaults$p = configWithDefaults.pathnames) === null || _configWithDefaults$p === void 0 ? void 0 : _configWithDefaults$p[internalTemplateName] : undefined,
        request,
        resolvedLocale: locale
      }));
    }
    return response;
  };
}

exports.default = createMiddleware;
